/**
 * @typedef Result
 * @property {string} type
 * @property {number} raw
 * @property {number} gzip
 * @property {string} rawWin
 * @property {string} gzipWin
 *
 * @typedef Datum
 * @property {boolean} htmlMinifierExploded
 * @property {string} name
 * @property {Array<Result>} results
 * @property {string} url
 */

import {Buffer} from 'node:buffer'
import fs from 'node:fs/promises'
import {promisify} from 'node:util'
import zlib from 'node:zlib'
import htmlMinifier from 'html-minifier'
import pAll from 'p-all'
import rehypeParse from 'rehype-parse'
import rehypePresetMinify from 'rehype-preset-minify'
import rehypeStringify from 'rehype-stringify'
import {fetch} from 'undici'
import {unified} from 'unified'

const gzip = promisify(zlib.gzip)

const cacheUrl = new URL('../benchmark-cache/', import.meta.url)

await fs.mkdir(cacheUrl, {recursive: true})

/** @type {Array<[name: string, url: string]>} */
const benchmarks = [
  ['amazon', 'https://www.amazon.co.uk/'],
  ['bbc', 'https://www.bbc.co.uk/'],
  [
    'bootstrap',
    'https://getbootstrap.com/docs/4.4/getting-started/introduction/'
  ],
  ['ecmascript', 'https://tc39.es/ecma262/'],
  ['eloquent', 'https://eloquentjavascript.net/20_node.html'],
  ['compat-table', 'https://kangax.github.io/compat-table/es6/'],
  ['github', 'https://github.com'],
  ['google', 'https://www.google.com'],
  ['guardian', 'https://www.theguardian.com'],
  ['html', 'https://html.spec.whatwg.org'],
  ['linkedin', 'https://www.linkedin.com/'],
  ['microsoft', 'https://www.microsoft.com'],
  ['nbc', 'https://www.nbc.com'],
  ['npm', 'https://www.npmjs.com'],
  ['nytimes', 'https://www.nytimes.com'],
  ['slack', 'https://slack.com'],
  ['stackoverflow', 'https://stackoverflow.com'],
  // ['twitter', 'https://twitter.com'],
  ['vice', 'https://www.vice.com'],
  ['wikipedia', 'https://en.wikipedia.org/wiki/President_of_the_United_States']
]

// Based on:
// <https://github.com/kangax/html-minifier/blob/gh-pages/sample-cli-config-file.conf>
// but passed through the CLI normalization:
// <https://github.com/kangax/html-minifier/blob/346f73d/cli.js#L100>
// and defaults removed for brevity:
// <https://github.com/kangax/html-minifier>
const htmlMinifierOptions = {
  collapseBooleanAttributes: true,
  collapseWhitespace: true,
  // CustomAttrCollapse: /.*/,
  decodeEntities: true,
  ignoreCustomFragments: [/<#[\s\S]*?#>/, /<%[\s\S]*?%>/, /<\?[\s\S]*?\?>/],
  includeAutoGeneratedTags: false,
  maxLineLength: 0,
  minifyCSS: true,
  minifyJS: true,
  processConditionalComments: true,
  processScripts: ['text/html'],
  removeAttributeQuotes: true,
  removeComments: true,
  removeEmptyAttributes: true,
  removeOptionalTags: true,
  removeRedundantAttributes: true,
  removeScriptTypeAttributes: true,
  removeStyleLinkTypeAttributes: true,
  removeTagWhitespace: true,
  sortAttributes: true,
  sortClassName: true,
  trimCustomFragments: true,
  useShortDoctype: true
}

const data = await pAll(
  benchmarks.map(function ([name, url]) {
    return async function () {
      const folderUrl = new URL(name + '/', cacheUrl)
      const inputUrl = new URL('index.html', folderUrl)

      /** @type {string} */
      let file

      try {
        file = String(await fs.readFile(inputUrl))
      } catch (error) {
        const exception = /** @type {NodeJS.ErrnoException} */ (error)

        if (exception.code !== 'ENOENT') {
          throw exception
        }

        const [response] = await Promise.all([
          fetch(url, {redirect: 'follow'}),
          fs.mkdir(folderUrl, {recursive: true})
        ])

        if (response.status !== 200) {
          throw new Error(
            'Could not get `' + url + '` (' + response.status + ')'
          )
        }

        file = await response.text()

        if (file.length < 1024) {
          throw new Error('Empty response from ' + url)
        }

        await fs.writeFile(inputUrl, file)
      }

      const rehypeResult = String(
        await unified()
          .use(rehypeParse)
          .use(rehypePresetMinify)
          .use(rehypeStringify)
          .process(file)
      )

      let htmlMinifierResult = file
      let htmlMinifierExploded = false

      try {
        htmlMinifierResult = htmlMinifier.minify(file, htmlMinifierOptions)
      } catch (error) {
        htmlMinifierExploded = true
        const exception = /** @type {Error} */ (error)
        console.warn(
          'html-minifier error (%s)',
          name,
          String(exception.stack || '').slice(0, 2 ** 10)
        )
      }

      // GZip and write results for inspection.
      const [originalGzipped, rehypeGzipped, htmlMinifierGzipped] =
        await Promise.all([
          gzip(file),
          gzip(rehypeResult),
          gzip(htmlMinifierResult),
          fs.writeFile(new URL('rehype.html', folderUrl), rehypeResult),
          fs.writeFile(
            new URL('html-minifier.html', folderUrl),
            htmlMinifierResult
          )
        ])

      /** @type {Array<[string, string, Buffer]>} */
      const base = [
        ['original', file, originalGzipped],
        ['rehype-minify', rehypeResult, rehypeGzipped],
        ['html-minifier', htmlMinifierResult, htmlMinifierGzipped]
      ]

      const sized = base.map(function ([type, file, gzipped]) {
        return {
          type,
          raw: Buffer.byteLength(file),
          gzip: Buffer.byteLength(gzipped)
        }
      })

      const original = sized[0]

      console.log('âœ… %s', name)
      /** @type {Datum} */
      return {
        name,
        url,
        htmlMinifierExploded,
        results: sized.map(function (d) {
          return {
            ...d,
            rawWin: win(original.raw, d.raw),
            gzipWin: win(original.gzip, d.gzip)
          }
        })
      }
    }
  }),
  {concurrency: 4}
)

data.sort(function (a, b) {
  return a.name.localeCompare(b.name)
})

await fs.writeFile(
  new URL('benchmark-results.json', import.meta.url),
  JSON.stringify(data, undefined, 2) + '\n'
)

/**
 * @param {number} input
 * @param {number} output
 * @returns {string}
 */
function win(input, output) {
  return (((input / output) % 1) * 100).toFixed(2) + '%'
}
