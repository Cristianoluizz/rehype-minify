import fs from 'fs'
import path from 'path'
import {inspect} from 'util'
import dox from 'dox'
import remark from 'remark'
import {rehype} from 'rehype'
import {u} from 'unist-builder'
import {toVFile} from 'to-vfile'
import {trough} from 'trough'
import author from 'parse-author'
import strip from 'strip-indent'
import preset from 'remark-preset-wooorm'

const pkg = JSON.parse(fs.readFileSync('package.json'))

const proc = remark().use({settings: preset.settings})

export const pipelineReadme = trough()
  .use((ctx, next) => {
    toVFile.read(path.join(ctx.root, 'package.json'), (error, file) => {
      ctx.config = file ? JSON.parse(String(file)) : {}
      next(error)
    })
  })
  .use((ctx, next) => {
    toVFile.read(path.join(ctx.root, 'index.js'), (error, script) => {
      if (error) {
        next(error.code === 'ENOENT' ? null : error)
      } else {
        ctx.script = script

        const comments = dox.parseComments(String(script))[0] || {}
        const tags = comments.tags || []
        let index = -1
        while (++index < tags.length) {
          ctx.config[tags[index].type] = tags[index].string
        }

        next()
      }
    })
  })
  .use(async (ctx) => {
    const config = ctx.config
    const overview = config.fileoverview || config.description
    const licensee = author(config.author)
    let example = config.example
    const repo = pkg.repository
    const org = repo.split('/').slice(0, -1).join('/')
    const branchBase = repo + '/blob/main'
    const health = org + '/.github'
    const hBranchBase = health + '/blob/main'
    const slug = repo.split('/').slice(-2).join('/')

    let tree = [
      u('html', '<!--This file is generated by `build-packages.js`-->'),
      u('heading', {depth: 1}, [u('text', config.name)])
    ]

    tree.push(
      u('paragraph', [
        u('linkReference', {identifier: 'build'}, [
          u('imageReference', {identifier: 'build-badge', alt: 'Build'})
        ]),
        u('text', '\n'),
        u('linkReference', {identifier: 'coverage'}, [
          u('imageReference', {identifier: 'coverage-badge', alt: 'Coverage'})
        ]),
        u('text', '\n'),
        u('linkReference', {identifier: 'downloads'}, [
          u('imageReference', {identifier: 'downloads-badge', alt: 'Downloads'})
        ]),
        u('text', '\n'),
        u('linkReference', {identifier: 'size'}, [
          u('imageReference', {identifier: 'size-badge', alt: 'Size'})
        ]),
        u('text', '\n'),
        u('linkReference', {identifier: 'collective'}, [
          u('imageReference', {identifier: 'sponsors-badge', alt: 'Sponsors'})
        ]),
        u('text', '\n'),
        u('linkReference', {identifier: 'collective'}, [
          u('imageReference', {identifier: 'backers-badge', alt: 'Backers'})
        ]),
        u('text', '\n'),
        u('linkReference', {identifier: 'chat'}, [
          u('imageReference', {identifier: 'chat-badge', alt: 'Chat'})
        ])
      ])
    )

    tree = tree.concat(
      proc.parse(
        strip(
          overview + (overview.charAt(overview.length - 1) === '.' ? '' : '.')
        )
      ).children
    )

    const mod = await import(ctx.script.path)
    const specifiers = Object.keys(mod).filter((d) => d !== 'default')

    tree.push(
      u('heading', {depth: 2}, [u('text', 'Install')]),
      u('paragraph', [
        u('text', 'This package is '),
        u('linkReference', {identifier: 'esm', referenceType: 'full'}, [
          u('text', 'ESM only')
        ]),
        u('text', ':\nNode 12+ is needed to use it and it must be '),
        u('inlineCode', 'imported'),
        u('text', 'ed instead of '),
        u('inlineCode', 'required'),
        u('text', 'd.')
      ]),
      u('paragraph', [
        u('linkReference', {identifier: 'npm', referenceType: 'collapsed'}, [
          u('text', 'npm')
        ]),
        u('text', ':')
      ]),
      u('code', {lang: 'sh'}, 'npm install ' + config.name),
      u('paragraph', [
        ...(specifiers.length > 0
          ? [
              u('text', 'This package exports the following identifiers:\n'),
              ...specifiers.flatMap((d, i) => {
                const node = u('inlineCode', d)
                return i ? [u('text', ', '), node] : node
              }),
              u('text', '.\n')
            ]
          : [u('text', 'This package exports no identifiers.\n')]),
        ...('default' in mod && 'name' in mod.default
          ? [
              u('text', 'The default export is '),
              u('inlineCode', mod.default.name)
            ]
          : [u('text', 'There is no default export.')])
      ])
    )

    if (ctx.plugins.includes(config.name)) {
      const id = config.name
        .replace(/-([a-z])/g, ($0, $1) => $1.toUpperCase())
        .replace(/Javascript/g, 'JavaScript')

      if (!('default' in mod) || mod.default.name !== id) {
        throw new Error(
          'Expected default export called `' +
            id +
            '`' +
            (mod.default ? ', not `' + mod.default.name + '`' : '')
        )
      }

      tree.push(
        u('heading', {depth: 2}, [u('text', 'Use')]),
        u('paragraph', [u('text', 'On the API:')]),
        u(
          'code',
          {lang: 'diff'},
          [
            " import {unified} from 'unified'",
            " import rehypeParse from 'rehype-parse'",
            '+import ' + id + " from '" + config.name + "'",
            " import rehypeStringify from 'rehype-stringify'",
            '',
            ' unified()',
            '   .use(rehypeParse)',
            '+  .use(' + id + ')',
            '   .use(rehypeStringify)',
            "   .process('<span>some html</span>', function (err, file) {",
            '     console.error(report(err || file))',
            '     console.log(String(file))',
            '   })'
          ].join('\n')
        ),
        u('paragraph', [u('text', 'On the CLI:')]),
        u(
          'code',
          {lang: 'sh'},
          'rehype input.html --use ' +
            config.name.replace(/^rehype-/, '') +
            ' --output output.html'
        )
      )
    }

    if (config.longdescription) {
      tree = tree.concat(proc.parse(strip(config.longdescription)).children)
    }

    if (example && ctx.script) {
      let options = example.slice(0, example.indexOf('\n'))

      if (options.trim()) {
        try {
          options = JSON.parse(options)
          example = example.slice(example.indexOf('\n') + 1)
        } catch {
          options = {}
        }
      }

      example = strip(example)

      tree.push(u('heading', {depth: 2}, [u('text', 'Example')]))

      if (options.plugin) {
        tree.push(
          u('paragraph', [
            u('text', 'With '),
            u('inlineCode', inspect(options.plugin)),
            u('text', ' as options.')
          ])
        )
      }

      tree.push(
        u('heading', {depth: 5}, [u('text', 'In')]),
        u('code', {lang: 'html'}, example),
        u('heading', {depth: 5}, [u('text', 'Out')]),
        u(
          'code',
          {lang: 'html'},
          rehype()
            .data('settings', options.processor || {fragment: true})
            .use(mod.default, options.plugin || undefined)
            .processSync(example)
            .toString()
            .trim()
        )
      )
    }

    tree.push(
      u('heading', {depth: 2}, [u('text', 'Contribute')]),
      u('paragraph', [
        u('text', 'See '),
        u('linkReference', {identifier: 'contributing'}, [
          u('inlineCode', 'contributing.md')
        ]),
        u('text', ' in '),
        u('linkReference', {identifier: 'health'}, [
          u('inlineCode', 'rehypejs/.github')
        ]),
        u('text', ' for ways\nto get started.\nSee '),
        u('linkReference', {identifier: 'support'}, [
          u('inlineCode', 'support.md')
        ]),
        u('text', ' for ways to get help.')
      ]),
      u('paragraph', [
        u('text', 'This project has a '),
        u('linkReference', {identifier: 'coc'}, [u('text', 'code of conduct')]),
        u(
          'text',
          '.\nBy interacting with this repository, organization, or community you agree to\nabide by its terms.'
        )
      ]),
      u('heading', {depth: 2}, [u('text', 'License')]),
      u('paragraph', [
        u('linkReference', {identifier: 'license'}, [
          u('text', config.license)
        ]),
        u('text', ' Â© '),
        u('linkReference', {identifier: 'author'}, [u('text', licensee.name)])
      ]),
      u('definition', {
        identifier: 'build-badge',
        url: 'https://github.com/' + slug + '/workflows/main/badge.svg'
      }),
      u('definition', {
        identifier: 'build',
        url: 'https://github.com/' + slug + '/actions'
      }),
      u('definition', {
        identifier: 'coverage-badge',
        url: 'https://img.shields.io/codecov/c/github/' + slug + '.svg'
      }),
      u('definition', {
        identifier: 'coverage',
        url: 'https://codecov.io/github/' + slug
      }),
      u('definition', {
        identifier: 'downloads-badge',
        url: 'https://img.shields.io/npm/dm/' + config.name + '.svg'
      }),
      u('definition', {
        identifier: 'downloads',
        url: 'https://www.npmjs.com/package/' + config.name
      }),
      u('definition', {
        identifier: 'size-badge',
        url:
          'https://img.shields.io/bundlephobia/minzip/' + config.name + '.svg'
      }),
      u('definition', {
        identifier: 'size',
        url: 'https://bundlephobia.com/result?p=' + config.name
      }),
      u('definition', {
        identifier: 'sponsors-badge',
        url: 'https://opencollective.com/unified/sponsors/badge.svg'
      }),
      u('definition', {
        identifier: 'backers-badge',
        url: 'https://opencollective.com/unified/backers/badge.svg'
      }),
      u('definition', {
        identifier: 'collective',
        url: 'https://opencollective.com/unified'
      }),
      u('definition', {
        identifier: 'chat-badge',
        url: 'https://img.shields.io/badge/chat-discussions-success.svg'
      }),
      u('definition', {
        identifier: 'chat',
        url: 'https://github.com/rehypejs/rehype/discussions'
      }),
      u('definition', {
        identifier: 'esm',
        url: 'https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c'
      }),
      u('definition', {
        identifier: 'npm',
        url: 'https://docs.npmjs.com/cli/install'
      }),
      u('definition', {identifier: 'health', url: health}),
      u('definition', {
        identifier: 'contributing',
        url: hBranchBase + '/contributing.md'
      }),
      u('definition', {
        identifier: 'support',
        url: hBranchBase + '/support.md'
      }),
      u('definition', {
        identifier: 'coc',
        url: hBranchBase + '/code-of-conduct.md'
      }),
      u('definition', {identifier: 'license', url: branchBase + '/license'}),
      u('definition', {identifier: 'author', url: licensee.url})
    )

    ctx.readme = toVFile(path.join(ctx.root, 'readme.md'))
    ctx.readme.value = proc.stringify(u('root', tree), ctx.readme)
  })
  .use((ctx, next) => {
    fs.writeFile(ctx.readme.path, String(ctx.readme), next)
  })
  .use((ctx) => {
    ctx.readme.stored = true
  })
