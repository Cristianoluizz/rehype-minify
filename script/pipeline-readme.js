/**
 * @typedef {import('trough').Callback} Next
 * @typedef {import('vfile').VFile} VFile
 * @typedef {import('type-fest').PackageJson} PackageJson
 * @typedef {import('mdast').BlockContent} BlockContent
 * @typedef {import('mdast').DefinitionContent} DefinitionContent
 * @typedef {import('mdast').PhrasingContent} PhrasingContent
 * @typedef {import('mdast').Root} Root
 */

import fs from 'node:fs'
import path from 'node:path'
import {inspect} from 'node:util'
import {parse} from 'comment-parser'
import {remark} from 'remark'
import {rehype} from 'rehype'
import {toVFile} from 'to-vfile'
import {trough} from 'trough'
import author from 'parse-author'
import strip from 'strip-indent'
import remarkPresetWooorm from 'remark-preset-wooorm'

/** @type {PackageJson} */
const pkg = JSON.parse(String(fs.readFileSync('package.json')))

const proc = remark().use({settings: remarkPresetWooorm.settings})

export const pipelineReadme = trough()
  .use(
    /**
     * @param {{root: string, ancestor: string, plugins: Array<string>, package: VFile, contributors: Array<string>, files: Array<string>, tests: boolean, packageValue?: PackageJson}} ctx
     * @param {Next} next
     */
    (ctx) => {
      ctx.packageValue = JSON.parse(String(ctx.package))
    }
  )
  .use(
    /**
     * @param {{root: string, ancestor: string, plugins: Array<string>, package: VFile, contributors: Array<string>, files: Array<string>, tests: boolean, packageValue: PackageJson, config?: Record<string, string>, script?: VFile}} ctx
     * @param {Next} next
     */
    (ctx, next) => {
      toVFile.read(path.join(ctx.root, 'index.js'), (error, script) => {
        if (error) {
          next(error)
        } else if (script) {
          ctx.script = script
          /** @type {Record<string, string>} */
          ctx.config = {}

          const tags = parse(String(script), {
            spacing: 'preserve'
          })[0].tags
          let index = -1
          while (++index < tags.length) {
            const tag = tags[index]
            ctx.config[tag.tag] = strip(
              tag.description.replace(/^\r?\n|\r?\n$/g, '')
            )
          }

          next()
        }
      })
    }
  )
  .use(
    /**
     * @param {{root: string, ancestor: string, plugins: Array<string>, package: VFile, contributors: Array<string>, files: Array<string>, tests: boolean, packageValue: PackageJson, config: Record<string, string>, script: VFile, readme?: VFile}} ctx
     * @param {Next} next
     */
    // eslint-disable-next-line complexity
    async (ctx) => {
      const packageValue = ctx.packageValue
      const config = ctx.config

      if (typeof pkg.repository !== 'string') {
        throw new TypeError(
          'Expected `repository` in root `package.json` as a string'
        )
      }

      if (typeof packageValue.author !== 'string') {
        throw new TypeError(
          'Expected `author` in local `package.json` as a string'
        )
      }

      if (!packageValue.name) {
        throw new Error('Expected `name` in local `package.json`')
      }

      const overview = String(
        config.fileoverview || packageValue.description || ''
      )
      const licensee = author(packageValue.author)
      const example = config.example
      const repo = pkg.repository
      const org = repo.split('/').slice(0, -1).join('/')
      const branchBase = repo + '/blob/main'
      const health = org + '/.github'
      const hBranchBase = health + '/blob/main'
      const slug = repo.split('/').slice(-2).join('/')

      /** @type {Array<BlockContent|DefinitionContent>} */
      const tree = [
        {
          type: 'html',
          value: '<!--This file is generated by `build-packages.js`-->'
        }
      ]

      tree.push(
        {
          type: 'heading',
          depth: 1,
          children: [{type: 'text', value: packageValue.name}]
        },
        {
          type: 'paragraph',
          children: [
            {
              type: 'linkReference',
              identifier: 'build',
              referenceType: 'full',
              children: [
                {
                  type: 'imageReference',
                  identifier: 'build-badge',
                  referenceType: 'full',
                  alt: 'Build'
                }
              ]
            },
            {type: 'text', value: '\n'},
            {
              type: 'linkReference',
              identifier: 'coverage',
              referenceType: 'full',
              children: [
                {
                  type: 'imageReference',
                  identifier: 'coverage-badge',
                  referenceType: 'full',
                  alt: 'Coverage'
                }
              ]
            },
            {type: 'text', value: '\n'},
            {
              type: 'linkReference',
              identifier: 'downloads',
              referenceType: 'full',
              children: [
                {
                  type: 'imageReference',
                  identifier: 'downloads-badge',
                  referenceType: 'full',
                  alt: 'Downloads'
                }
              ]
            },
            {type: 'text', value: '\n'},
            {
              type: 'linkReference',
              identifier: 'size',
              referenceType: 'full',
              children: [
                {
                  type: 'imageReference',
                  identifier: 'size-badge',
                  referenceType: 'full',
                  alt: 'Size'
                }
              ]
            },
            {type: 'text', value: '\n'},
            {
              type: 'linkReference',
              identifier: 'collective',
              referenceType: 'full',
              children: [
                {
                  type: 'imageReference',
                  identifier: 'sponsors-badge',
                  referenceType: 'full',
                  alt: 'Sponsors'
                }
              ]
            },
            {type: 'text', value: '\n'},
            {
              type: 'linkReference',
              identifier: 'collective',
              referenceType: 'full',
              children: [
                {
                  type: 'imageReference',
                  identifier: 'backers-badge',
                  referenceType: 'full',
                  alt: 'Backers'
                }
              ]
            },
            {type: 'text', value: '\n'},
            {
              type: 'linkReference',
              identifier: 'chat',
              referenceType: 'full',
              children: [
                {
                  type: 'imageReference',
                  identifier: 'chat-badge',
                  referenceType: 'full',
                  alt: 'Chat'
                }
              ]
            }
          ]
        }
      )

      const desc = /** @type {Root} */ (
        proc.parse(
          strip(
            overview + (overview.charAt(overview.length - 1) === '.' ? '' : '.')
          )
        )
      )

      // @ts-expect-error: Assume block content.
      tree.push(...desc.children)

      /**
       * @type {Record<string, unknown> & {default?: Function}}
       */
      const mod = await import(ctx.script.path)
      const specifiers = Object.keys(mod).filter((d) => d !== 'default')

      /** @type {Array<PhrasingContent>} */
      const info = []

      if (specifiers.length > 0) {
        info.push({
          type: 'text',
          value: 'This package exports the following identifiers:\n'
        })

        let index = -1
        while (++index < specifiers.length) {
          if (index !== 0) {
            info.push({type: 'text', value: ', '})
          }

          info.push({type: 'inlineCode', value: specifiers[index]})
        }

        info.push({type: 'text', value: '.'})
      } else {
        info.push({
          type: 'text',
          value: 'This package exports no identifiers.'
        })
      }

      if ('default' in mod && mod.default && 'name' in mod.default) {
        info.push(
          {type: 'text', value: '\nThe default export is '},
          {type: 'inlineCode', value: mod.default.name}
        )
      } else {
        info.push({type: 'text', value: '\nThere is no default export.'})
      }

      tree.push(
        {
          type: 'heading',
          depth: 2,
          children: [{type: 'text', value: 'Install'}]
        },
        {
          type: 'paragraph',
          children: [
            {type: 'text', value: 'This package is '},
            {
              type: 'linkReference',
              identifier: 'esm',
              referenceType: 'full',
              children: [{type: 'text', value: 'ESM only'}]
            },
            {
              type: 'text',
              value: ':\nNode 12+ is needed to use it and it must be '
            },
            {type: 'inlineCode', value: 'imported'},
            {type: 'text', value: 'ed instead of '},
            {type: 'inlineCode', value: 'required'},
            {type: 'text', value: 'd.'}
          ]
        },
        {
          type: 'paragraph',
          children: [
            {
              type: 'linkReference',
              identifier: 'npm',
              referenceType: 'collapsed',
              children: [{type: 'text', value: 'npm'}]
            },
            {type: 'text', value: ':'}
          ]
        },
        {type: 'code', lang: 'sh', value: 'npm install ' + packageValue.name},
        {type: 'paragraph', children: info}
      )

      if (ctx.plugins.includes(packageValue.name)) {
        const id = packageValue.name
          .replace(/-([a-z])/g, (_, /** @type {string} */ $1) =>
            $1.toUpperCase()
          )
          .replace(/Javascript/g, 'JavaScript')

        if (!('default' in mod) || !mod.default || mod.default.name !== id) {
          throw new Error(
            'Expected default export called `' +
              id +
              '`' +
              (mod.default ? ', not `' + mod.default.name + '`' : '')
          )
        }

        tree.push(
          {type: 'heading', depth: 2, children: [{type: 'text', value: 'Use'}]},
          {
            type: 'paragraph',
            children: [{type: 'text', value: 'On the API:'}]
          },
          {
            type: 'code',
            lang: 'diff',
            value: [
              " import {unified} from 'unified'",
              " import rehypeParse from 'rehype-parse'",
              '+import ' + id + " from '" + packageValue.name + "'",
              " import rehypeStringify from 'rehype-stringify'",
              '',
              ' unified()',
              '   .use(rehypeParse)',
              '+  .use(' + id + ')',
              '   .use(rehypeStringify)',
              "   .process('<span>some html</span>', function (err, file) {",
              '     console.error(report(err || file))',
              '     console.log(String(file))',
              '   })'
            ].join('\n')
          },
          {type: 'paragraph', children: [{type: 'text', value: 'On the CLI:'}]},
          {
            type: 'code',
            lang: 'sh',
            value:
              'rehype input.html --use ' +
              packageValue.name.replace(/^rehype-/, '') +
              ' --output output.html'
          }
        )
      }

      if (config.longdescription) {
        const desc = /** @type {Root} */ (
          proc.parse(strip(config.longdescription))
        )

        // @ts-expect-error: assume block content.
        tree.push(...desc.children)
      }

      if (typeof example === 'string' && ctx.script) {
        /** @type {Record<string, unknown>} */
        let options = {}
        const lines = example.split('\n')

        if (lines[0].trim()) {
          try {
            options = JSON.parse(lines[0])
            lines.splice(0, 1)
          } catch {}
        }

        const exampleValue = strip(lines.join('\n'))

        tree.push({
          type: 'heading',
          depth: 2,
          children: [{type: 'text', value: 'Example'}]
        })

        if (options.plugin) {
          tree.push({
            type: 'paragraph',
            children: [
              {type: 'text', value: 'With '},
              {type: 'inlineCode', value: inspect(options.plugin)},
              {type: 'text', value: ' as options.'}
            ]
          })
        }

        tree.push(
          {type: 'heading', depth: 5, children: [{type: 'text', value: 'In'}]},
          {type: 'code', lang: 'html', value: exampleValue},
          {type: 'heading', depth: 5, children: [{type: 'text', value: 'Out'}]},
          {
            type: 'code',
            lang: 'html',
            value: rehype()
              .data('settings', options.processor || {fragment: true})
              // @ts-expect-error: Assume `default` is usable.
              .use(mod.default, options.plugin || undefined)
              .processSync(exampleValue)
              .toString()
              .trim()
          }
        )
      }

      tree.push(
        {
          type: 'heading',
          depth: 2,
          children: [{type: 'text', value: 'Contribute'}]
        },
        {
          type: 'paragraph',
          children: [
            {type: 'text', value: 'See '},
            {
              type: 'linkReference',
              referenceType: 'full',
              identifier: 'contributing',
              children: [{type: 'inlineCode', value: 'contributing.md'}]
            },
            {type: 'text', value: ' in '},
            {
              type: 'linkReference',
              referenceType: 'full',
              identifier: 'health',
              children: [{type: 'inlineCode', value: 'rehypejs/.github'}]
            },
            {type: 'text', value: ' for ways\nto get started.\nSee '},
            {
              type: 'linkReference',
              referenceType: 'full',
              identifier: 'support',
              children: [{type: 'inlineCode', value: 'support.md'}]
            },
            {type: 'text', value: ' for ways to get help.'}
          ]
        },
        {
          type: 'paragraph',
          children: [
            {type: 'text', value: 'This project has a '},
            {
              type: 'linkReference',
              referenceType: 'full',
              identifier: 'coc',
              children: [{type: 'text', value: 'code of conduct'}]
            },
            {
              type: 'text',
              value:
                '.\nBy interacting with this repository, organization, or community you agree to\nabide by its terms.'
            }
          ]
        },
        {
          type: 'heading',
          depth: 2,
          children: [{type: 'text', value: 'License'}]
        },
        {
          type: 'paragraph',
          children: [
            {
              type: 'linkReference',
              referenceType: 'full',
              identifier: 'license',
              children: [
                {type: 'text', value: String(packageValue.license || '')}
              ]
            },
            {type: 'text', value: ' © '},
            {
              type: 'linkReference',
              referenceType: 'full',
              identifier: 'author',
              children: [{type: 'text', value: String(licensee.name || '')}]
            }
          ]
        },
        {
          type: 'definition',
          identifier: 'build-badge',
          url: 'https://github.com/' + slug + '/workflows/main/badge.svg'
        },
        {
          type: 'definition',
          identifier: 'build',
          url: 'https://github.com/' + slug + '/actions'
        },
        {
          type: 'definition',
          identifier: 'coverage-badge',
          url: 'https://img.shields.io/codecov/c/github/' + slug + '.svg'
        },
        {
          type: 'definition',
          identifier: 'coverage',
          url: 'https://codecov.io/github/' + slug
        },
        {
          type: 'definition',
          identifier: 'downloads-badge',
          url: 'https://img.shields.io/npm/dm/' + packageValue.name + '.svg'
        },
        {
          type: 'definition',
          identifier: 'downloads',
          url: 'https://www.npmjs.com/package/' + packageValue.name
        },
        {
          type: 'definition',
          identifier: 'size-badge',
          url:
            'https://img.shields.io/bundlephobia/minzip/' +
            packageValue.name +
            '.svg'
        },
        {
          type: 'definition',
          identifier: 'size',
          url: 'https://bundlephobia.com/result?p=' + packageValue.name
        },
        {
          type: 'definition',
          identifier: 'sponsors-badge',
          url: 'https://opencollective.com/unified/sponsors/badge.svg'
        },
        {
          type: 'definition',
          identifier: 'backers-badge',
          url: 'https://opencollective.com/unified/backers/badge.svg'
        },
        {
          type: 'definition',
          identifier: 'collective',
          url: 'https://opencollective.com/unified'
        },
        {
          type: 'definition',
          identifier: 'chat-badge',
          url: 'https://img.shields.io/badge/chat-discussions-success.svg'
        },
        {
          type: 'definition',
          identifier: 'chat',
          url: 'https://github.com/rehypejs/rehype/discussions'
        },
        {
          type: 'definition',
          identifier: 'esm',
          url: 'https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c'
        },
        {
          type: 'definition',
          identifier: 'npm',
          url: 'https://docs.npmjs.com/cli/install'
        },
        {
          type: 'definition',
          identifier: 'health',
          url: health
        },
        {
          type: 'definition',
          identifier: 'contributing',
          url: hBranchBase + '/contributing.md'
        },
        {
          type: 'definition',
          identifier: 'support',
          url: hBranchBase + '/support.md'
        },
        {
          type: 'definition',
          identifier: 'coc',
          url: hBranchBase + '/code-of-conduct.md'
        },
        {
          type: 'definition',
          identifier: 'license',
          url: branchBase + '/license'
        },
        {
          type: 'definition',
          identifier: 'author',
          url: String(licensee.url || '')
        }
      )

      ctx.readme = toVFile(path.join(ctx.root, 'readme.md'))
      /** @type {Root} */
      const root = {type: 'root', children: tree}
      ctx.readme.value = proc.stringify(root, ctx.readme)
    }
  )
  .use(
    /**
     * @param {{readme: VFile}} ctx
     * @param {Next} next
     */
    (ctx, next) => {
      fs.writeFile(ctx.readme.path, String(ctx.readme), next)
    }
  )
  .use(
    /**
     * @param {{readme: VFile}} ctx
     */
    (ctx) => {
      ctx.readme.stored = true
    }
  )
